# Anti-Patterns

Common mistakes to avoid in Convex + Next.js applications.

---

## üö´ Mutation Impurity

**Problem**: Non-deterministic code in mutations breaks automatic retries.

```typescript
// ‚ùå BAD
export const createTask = mutation({
  handler: async (ctx, args) => {
    await ctx.db.insert("tasks", {
      ...args,
      createdAt: Date.now(),        // Non-deterministic
      id: crypto.randomUUID(),       // Non-deterministic
    });
  },
});

// ‚úÖ GOOD
export const createTask = mutation({
  args: { title: v.string(), createdAt: v.number() },
  handler: async (ctx, args) => {
    await ctx.db.insert("tasks", {
      title: args.title,
      createdAt: args.createdAt,    // Passed from caller
      // _id is auto-generated by Convex
    });
  },
});
```

üìñ [Zen: Don't misuse actions](https://docs.convex.dev/understanding/zen#dont-misuse-actions)

---

## üö´ Misusing Actions

**Problem**: Using actions when queries/mutations would work.

```typescript
// ‚ùå BAD: Action for simple DB read
export const getUser = action({
  handler: async (ctx, args) => {
    return await ctx.runQuery(api.users.get, args);
  },
});

// ‚úÖ GOOD: Just use a query
export const getUser = query({
  handler: async (ctx, args) => {
    return await ctx.db.get(args.userId);
  },
});
```

üìñ [Best practices: Prefer queries/mutations](https://docs.convex.dev/understanding/best-practices/other-recommendations#functions)

---

## üö´ No Access Control

**Problem**: Public functions without auth checks.

```typescript
// ‚ùå BAD: Anyone can delete any task
export const deleteTask = mutation({
  args: { taskId: v.id("tasks") },
  handler: async (ctx, args) => {
    await ctx.db.delete(args.taskId);
  },
});

// ‚úÖ GOOD: Auth + authorization
export const deleteTask = mutation({
  args: { taskId: v.id("tasks") },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new ConvexError("Unauthorized");
    
    const task = await ctx.db.get(args.taskId);
    if (task?.userId !== identity.subject) throw new ConvexError("Forbidden");
    
    await ctx.db.delete(args.taskId);
  },
});
```

üìñ [Access control](https://docs.convex.dev/understanding/best-practices/#how-5)

---

## üö´ Next.js Action Wrapper

**Problem**: Wrapping Convex mutations in `'use server'` adds latency and breaks reactivity.

```typescript
// ‚ùå BAD: Unnecessary layer
// app/actions.ts
"use server";
export async function createTask(title: string) {
  const convex = new ConvexHttpClient(process.env.CONVEX_URL!);
  return await convex.mutation(api.tasks.create, { title });
}

// ‚úÖ GOOD: Call Convex directly from client
// components/TaskForm.tsx
"use client";
const createTask = useMutation(api.tasks.create);
await createTask({ title });
```

---

## üö´ Waterfall Queries

**Problem**: Sequential queries instead of parallel.

```typescript
// ‚ùå BAD: Waterfall
const user = await ctx.db.get(userId);
const tasks = await ctx.db.query("tasks").withIndex("by_user", q => q.eq("userId", userId)).collect();
const projects = await ctx.db.query("projects").withIndex("by_user", q => q.eq("userId", userId)).collect();

// ‚úÖ GOOD: Parallel
const [user, tasks, projects] = await Promise.all([
  ctx.db.get(userId),
  ctx.db.query("tasks").withIndex("by_user", q => q.eq("userId", userId)).collect(),
  ctx.db.query("projects").withIndex("by_user", q => q.eq("userId", userId)).collect(),
]);
```

---

## üö´ Client-Side Filtering

**Problem**: Fetching all data and filtering in React.

```typescript
// ‚ùå BAD: Fetch all, filter in component
const allTasks = useQuery(api.tasks.list);
const myTasks = allTasks?.filter(t => t.userId === currentUserId);

// ‚úÖ GOOD: Filter in Convex query
const myTasks = useQuery(api.tasks.listByUser, { userId: currentUserId });
```

---

## üö´ Synchronous Params (Next.js 15)

**Problem**: Not awaiting params in Next.js 15.

```typescript
// ‚ùå BAD: Runtime error in Next.js 15
export default function Page({ params }: { params: { id: string } }) {
  const id = params.id;
}

// ‚úÖ GOOD
export default async function Page({ params }: { params: Promise<{ id: string }> }) {
  const { id } = await params;
}
```

---

## üö´ Manual Caching

**Problem**: Using `unstable_cache` or `React.cache` on Convex data.

```typescript
// ‚ùå BAD: Convex already handles caching
import { unstable_cache } from "next/cache";
const cachedQuery = unstable_cache(
  async () => await convex.query(api.tasks.list),
  ["tasks"],
  { revalidate: 60 }
);

// ‚úÖ GOOD: Trust Convex's reactivity
const tasks = useQuery(api.tasks.list);
// OR for SSR:
const preloaded = await preloadQuery(api.tasks.list);
```

---

## üö´ Full Table Scans

**Problem**: Queries without proper index usage.

```typescript
// ‚ùå BAD: Scans entire table
const tasks = await ctx.db
  .query("tasks")
  .filter(q => q.eq(q.field("status"), "todo"))
  .collect();

// ‚úÖ GOOD: Uses index
const tasks = await ctx.db
  .query("tasks")
  .withIndex("by_status", q => q.eq("status", "todo"))
  .collect();
```

---

## üö´ Floating Promises

**Problem**: Not awaiting promises causes subtle bugs.

```typescript
// ‚ùå BAD: Floating promises
export const scheduleReminder = mutation({
  handler: async (ctx, args) => {
    ctx.scheduler.runAfter(1000, api.notifications.send, args); // Not awaited!
    ctx.db.patch(args.taskId, { reminded: true }); // Not awaited!
  },
});

// ‚úÖ GOOD: All promises awaited
export const scheduleReminder = mutation({
  handler: async (ctx, args) => {
    await ctx.scheduler.runAfter(1000, api.notifications.send, args);
    await ctx.db.patch(args.taskId, { reminded: true });
  },
});
```

üìñ [Best practices: Await all promises](https://docs.convex.dev/understanding/best-practices/#await-all-promises)

---

## üö´ Missing Argument Validation

**Problem**: Public functions without `args` validators accept anything.

```typescript
// ‚ùå BAD: No validation
export const createTask = mutation({
  handler: async (ctx, args: any) => {
    await ctx.db.insert("tasks", args); // Accepts anything!
  },
});

// ‚úÖ GOOD: Explicit validators
export const createTask = mutation({
  args: { 
    title: v.string(),
    priority: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    await ctx.db.insert("tasks", args);
  },
});
```

üìñ [Best practices: Functions](https://docs.convex.dev/understanding/best-practices/other-recommendations#functions)

---

## Verification Checklist

- [ ] No `Date.now()` or `Math.random()` in mutations
- [ ] No unnecessary actions (prefer queries/mutations)
- [ ] All public functions have auth checks
- [ ] All public functions have `args` with validators
- [ ] All promises are `await`ed (no floating promises)
- [ ] No `'use server'` wrappers around Convex calls
- [ ] Parallel queries with `Promise.all`
- [ ] Filtering done in Convex, not React
- [ ] `await params` in Next.js 15 pages
- [ ] No manual caching on Convex data
- [ ] All `q.eq()` calls use indexes
- [ ] Sensitive logic in `internal*` functions
